// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Profile is a common stacktrace profile format.
//
// Measurements represented with this format should follow the
// following conventions:
//
// - Consumers should treat unset optional fields as if they had been
//   set with their default value.
//
// - When possible, measurements should be stored in "unsampled" form
//   that is most useful to humans.  There should be enough
//   information present to determine the original sampled values.
//
// - On-disk, the serialized proto must be gzip-compressed.
//
// - The profile is represented as a set of samples, where each sample
//   references a sequence of locations, and where each location belongs
//   to a mapping.
// - There is a N->1 relationship from sample.location_id entries to
//   locations. For every sample.location_id entry there must be a
//   unique Location with that id.
// - There is an optional N->1 relationship from locations to
//   mappings. For every nonzero Location.mapping_id there must be a
//   unique Mapping with that id.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file google/v1/profile.proto (package google.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from message google.v1.Profile
 */
export class Profile extends Message<Profile> {
  /**
   * A description of the samples associated with each Sample.value.
   * For a cpu profile this might be:
   *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
   * For a heap profile, this might be:
   *   [["allocations","count"], ["space","bytes"]],
   * If one of the values represents the number of events represented
   * by the sample, by convention it should be at index 0 and use
   * sample_type.unit == "count".
   *
   * @generated from field: repeated google.v1.ValueType sample_type = 1;
   */
  sampleType: ValueType[] = [];

  /**
   * The set of samples recorded in this profile.
   *
   * @generated from field: repeated google.v1.Sample sample = 2;
   */
  sample: Sample[] = [];

  /**
   * Mapping from address ranges to the image/binary/library mapped
   * into that address range.  mapping[0] will be the main binary.
   *
   * @generated from field: repeated google.v1.Mapping mapping = 3;
   */
  mapping: Mapping[] = [];

  /**
   * Useful program location
   *
   * @generated from field: repeated google.v1.Location location = 4;
   */
  location: Location[] = [];

  /**
   * Functions referenced by locations
   *
   * @generated from field: repeated google.v1.Function function = 5;
   */
  function: Function[] = [];

  /**
   * A common table for strings referenced by various messages.
   * string_table[0] must always be "".
   *
   * @generated from field: repeated string string_table = 6;
   */
  stringTable: string[] = [];

  /**
   * frames with Function.function_name fully matching the following
   * regexp will be dropped from the samples, along with their successors.
   *
   * Index into string table.
   *
   * @generated from field: int64 drop_frames = 7;
   */
  dropFrames = protoInt64.zero;

  /**
   * frames with Function.function_name fully matching the following
   * regexp will be kept, even if it matches drop_frames.
   *
   * Index into string table.
   *
   * @generated from field: int64 keep_frames = 8;
   */
  keepFrames = protoInt64.zero;

  /**
   * Time of collection (UTC) represented as nanoseconds past the epoch.
   *
   * @generated from field: int64 time_nanos = 9;
   */
  timeNanos = protoInt64.zero;

  /**
   * Duration of the profile, if a duration makes sense.
   *
   * @generated from field: int64 duration_nanos = 10;
   */
  durationNanos = protoInt64.zero;

  /**
   * The kind of events between sampled ocurrences.
   * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
   *
   * @generated from field: google.v1.ValueType period_type = 11;
   */
  periodType?: ValueType;

  /**
   * The number of events between sampled occurrences.
   *
   * @generated from field: int64 period = 12;
   */
  period = protoInt64.zero;

  /**
   * Freeform text associated to the profile.
   *
   * Indices into string table.
   *
   * @generated from field: repeated int64 comment = 13;
   */
  comment: bigint[] = [];

  /**
   * Index into the string table of the type of the preferred sample
   * value. If unset, clients should default to the last sample value.
   *
   * @generated from field: int64 default_sample_type = 14;
   */
  defaultSampleType = protoInt64.zero;

  constructor(data?: PartialMessage<Profile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.v1.Profile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sample_type", kind: "message", T: ValueType, repeated: true },
    { no: 2, name: "sample", kind: "message", T: Sample, repeated: true },
    { no: 3, name: "mapping", kind: "message", T: Mapping, repeated: true },
    { no: 4, name: "location", kind: "message", T: Location, repeated: true },
    { no: 5, name: "function", kind: "message", T: Function, repeated: true },
    { no: 6, name: "string_table", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "drop_frames", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "keep_frames", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "time_nanos", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "duration_nanos", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 11, name: "period_type", kind: "message", T: ValueType },
    { no: 12, name: "period", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 13, name: "comment", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
    { no: 14, name: "default_sample_type", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Profile {
    return new Profile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Profile {
    return new Profile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Profile {
    return new Profile().fromJsonString(jsonString, options);
  }

  static equals(a: Profile | PlainMessage<Profile> | undefined, b: Profile | PlainMessage<Profile> | undefined): boolean {
    return proto3.util.equals(Profile, a, b);
  }
}

/**
 * ValueType describes the semantics and measurement units of a value.
 *
 * @generated from message google.v1.ValueType
 */
export class ValueType extends Message<ValueType> {
  /**
   * Index into string table.
   *
   * @generated from field: int64 type = 1;
   */
  type = protoInt64.zero;

  /**
   * Index into string table.
   *
   * @generated from field: int64 unit = 2;
   */
  unit = protoInt64.zero;

  constructor(data?: PartialMessage<ValueType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.v1.ValueType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "unit", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValueType {
    return new ValueType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValueType {
    return new ValueType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValueType {
    return new ValueType().fromJsonString(jsonString, options);
  }

  static equals(a: ValueType | PlainMessage<ValueType> | undefined, b: ValueType | PlainMessage<ValueType> | undefined): boolean {
    return proto3.util.equals(ValueType, a, b);
  }
}

/**
 * Each Sample records values encountered in some program
 * context. The program context is typically a stack trace, perhaps
 * augmented with auxiliary information like the thread-id, some
 * indicator of a higher level request being handled etc.
 *
 * @generated from message google.v1.Sample
 */
export class Sample extends Message<Sample> {
  /**
   * The ids recorded here correspond to a Profile.location.id.
   * The leaf is at location_id[0].
   *
   * @generated from field: repeated uint64 location_id = 1;
   */
  locationId: bigint[] = [];

  /**
   * The type and unit of each value is defined by the corresponding
   * entry in Profile.sample_type. All samples must have the same
   * number of values, the same as the length of Profile.sample_type.
   * When aggregating multiple samples into a single sample, the
   * result has a list of values that is the element-wise sum of the
   * lists of the originals.
   *
   * @generated from field: repeated int64 value = 2;
   */
  value: bigint[] = [];

  /**
   * label includes additional context for this sample. It can include
   * things like a thread id, allocation size, etc
   *
   * @generated from field: repeated google.v1.Label label = 3;
   */
  label: Label[] = [];

  constructor(data?: PartialMessage<Sample>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.v1.Sample";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "location_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
    { no: 2, name: "value", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
    { no: 3, name: "label", kind: "message", T: Label, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Sample {
    return new Sample().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Sample {
    return new Sample().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Sample {
    return new Sample().fromJsonString(jsonString, options);
  }

  static equals(a: Sample | PlainMessage<Sample> | undefined, b: Sample | PlainMessage<Sample> | undefined): boolean {
    return proto3.util.equals(Sample, a, b);
  }
}

/**
 * @generated from message google.v1.Label
 */
export class Label extends Message<Label> {
  /**
   * Index into string table
   *
   * @generated from field: int64 key = 1;
   */
  key = protoInt64.zero;

  /**
   * At most one of the following must be present
   *
   * Index into string table
   *
   * @generated from field: int64 str = 2;
   */
  str = protoInt64.zero;

  /**
   * @generated from field: int64 num = 3;
   */
  num = protoInt64.zero;

  /**
   * Should only be present when num is present.
   * Specifies the units of num.
   * Use arbitrary string (for example, "requests") as a custom count unit.
   * If no unit is specified, consumer may apply heuristic to deduce the unit.
   * Consumers may also  interpret units like "bytes" and "kilobytes" as memory
   * units and units like "seconds" and "nanoseconds" as time units,
   * and apply appropriate unit conversions to these.
   *
   * Index into string table
   *
   * @generated from field: int64 num_unit = 4;
   */
  numUnit = protoInt64.zero;

  constructor(data?: PartialMessage<Label>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.v1.Label";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "str", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "num_unit", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Label {
    return new Label().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Label {
    return new Label().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Label {
    return new Label().fromJsonString(jsonString, options);
  }

  static equals(a: Label | PlainMessage<Label> | undefined, b: Label | PlainMessage<Label> | undefined): boolean {
    return proto3.util.equals(Label, a, b);
  }
}

/**
 * @generated from message google.v1.Mapping
 */
export class Mapping extends Message<Mapping> {
  /**
   * Unique nonzero id for the mapping.
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * Address at which the binary (or DLL) is loaded into memory.
   *
   * @generated from field: uint64 memory_start = 2;
   */
  memoryStart = protoInt64.zero;

  /**
   * The limit of the address range occupied by this mapping.
   *
   * @generated from field: uint64 memory_limit = 3;
   */
  memoryLimit = protoInt64.zero;

  /**
   * Offset in the binary that corresponds to the first mapped address.
   *
   * @generated from field: uint64 file_offset = 4;
   */
  fileOffset = protoInt64.zero;

  /**
   * The object this entry is loaded from.  This can be a filename on
   * disk for the main binary and shared libraries, or virtual
   * abstractions like "[vdso]".
   *
   * Index into string table
   *
   * @generated from field: int64 filename = 5;
   */
  filename = protoInt64.zero;

  /**
   * A string that uniquely identifies a particular program version
   * with high probability. E.g., for binaries generated by GNU tools,
   * it could be the contents of the .note.gnu.build-id field.
   *
   * Index into string table
   *
   * @generated from field: int64 build_id = 6;
   */
  buildId = protoInt64.zero;

  /**
   * The following fields indicate the resolution of symbolic info.
   *
   * @generated from field: bool has_functions = 7;
   */
  hasFunctions = false;

  /**
   * @generated from field: bool has_filenames = 8;
   */
  hasFilenames = false;

  /**
   * @generated from field: bool has_line_numbers = 9;
   */
  hasLineNumbers = false;

  /**
   * @generated from field: bool has_inline_frames = 10;
   */
  hasInlineFrames = false;

  constructor(data?: PartialMessage<Mapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.v1.Mapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "memory_start", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "memory_limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "file_offset", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "filename", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "build_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "has_functions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "has_filenames", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "has_line_numbers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "has_inline_frames", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Mapping {
    return new Mapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Mapping {
    return new Mapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Mapping {
    return new Mapping().fromJsonString(jsonString, options);
  }

  static equals(a: Mapping | PlainMessage<Mapping> | undefined, b: Mapping | PlainMessage<Mapping> | undefined): boolean {
    return proto3.util.equals(Mapping, a, b);
  }
}

/**
 * Describes function and line table debug information.
 *
 * @generated from message google.v1.Location
 */
export class Location extends Message<Location> {
  /**
   * Unique nonzero id for the location.  A profile could use
   * instruction addresses or any integer sequence as ids.
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * The id of the corresponding profile.Mapping for this location.
   * It can be unset if the mapping is unknown or not applicable for
   * this profile type.
   *
   * @generated from field: uint64 mapping_id = 2;
   */
  mappingId = protoInt64.zero;

  /**
   * The instruction address for this location, if available.  It
   * should be within [Mapping.memory_start...Mapping.memory_limit]
   * for the corresponding mapping. A non-leaf address may be in the
   * middle of a call instruction. It is up to display tools to find
   * the beginning of the instruction if necessary.
   *
   * @generated from field: uint64 address = 3;
   */
  address = protoInt64.zero;

  /**
   * Multiple line indicates this location has inlined functions,
   * where the last entry represents the caller into which the
   * preceding entries were inlined.
   *
   * E.g., if memcpy() is inlined into printf:
   *    line[0].function_name == "memcpy"
   *    line[1].function_name == "printf"
   *
   * @generated from field: repeated google.v1.Line line = 4;
   */
  line: Line[] = [];

  /**
   * Provides an indication that multiple symbols map to this location's
   * address, for example due to identical code folding by the linker. In that
   * case the line information above represents one of the multiple
   * symbols. This field must be recomputed when the symbolization state of the
   * profile changes.
   *
   * @generated from field: bool is_folded = 5;
   */
  isFolded = false;

  constructor(data?: PartialMessage<Location>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.v1.Location";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "mapping_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "address", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "line", kind: "message", T: Line, repeated: true },
    { no: 5, name: "is_folded", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Location {
    return new Location().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Location {
    return new Location().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Location {
    return new Location().fromJsonString(jsonString, options);
  }

  static equals(a: Location | PlainMessage<Location> | undefined, b: Location | PlainMessage<Location> | undefined): boolean {
    return proto3.util.equals(Location, a, b);
  }
}

/**
 * @generated from message google.v1.Line
 */
export class Line extends Message<Line> {
  /**
   * The id of the corresponding profile.Function for this line.
   *
   * @generated from field: uint64 function_id = 1;
   */
  functionId = protoInt64.zero;

  /**
   * Line number in source code.
   *
   * @generated from field: int64 line = 2;
   */
  line = protoInt64.zero;

  constructor(data?: PartialMessage<Line>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.v1.Line";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "function_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "line", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Line {
    return new Line().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Line {
    return new Line().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Line {
    return new Line().fromJsonString(jsonString, options);
  }

  static equals(a: Line | PlainMessage<Line> | undefined, b: Line | PlainMessage<Line> | undefined): boolean {
    return proto3.util.equals(Line, a, b);
  }
}

/**
 * @generated from message google.v1.Function
 */
export class Function extends Message<Function> {
  /**
   * Unique nonzero id for the function.
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * Name of the function, in human-readable form if available.
   *
   * Index into string table
   *
   * @generated from field: int64 name = 2;
   */
  name = protoInt64.zero;

  /**
   * Name of the function, as identified by the system.
   * For instance, it can be a C++ mangled name.
   *
   * Index into string table
   *
   * @generated from field: int64 system_name = 3;
   */
  systemName = protoInt64.zero;

  /**
   * Source file containing the function.
   *
   * Index into string table
   *
   * @generated from field: int64 filename = 4;
   */
  filename = protoInt64.zero;

  /**
   * Line number in source file.
   *
   * @generated from field: int64 start_line = 5;
   */
  startLine = protoInt64.zero;

  constructor(data?: PartialMessage<Function>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.v1.Function";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "name", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "system_name", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "filename", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "start_line", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Function {
    return new Function().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Function {
    return new Function().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Function {
    return new Function().fromJsonString(jsonString, options);
  }

  static equals(a: Function | PlainMessage<Function> | undefined, b: Function | PlainMessage<Function> | undefined): boolean {
    return proto3.util.equals(Function, a, b);
  }
}

