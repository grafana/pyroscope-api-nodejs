// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file settings/v1/recording_rules.proto (package settings.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { LabelPair } from "../../types/v1/types_pb.js";

/**
 * @generated from message settings.v1.GetRecordingRuleRequest
 */
export class GetRecordingRuleRequest extends Message<GetRecordingRuleRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<GetRecordingRuleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "settings.v1.GetRecordingRuleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRecordingRuleRequest {
    return new GetRecordingRuleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRecordingRuleRequest {
    return new GetRecordingRuleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRecordingRuleRequest {
    return new GetRecordingRuleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetRecordingRuleRequest | PlainMessage<GetRecordingRuleRequest> | undefined, b: GetRecordingRuleRequest | PlainMessage<GetRecordingRuleRequest> | undefined): boolean {
    return proto3.util.equals(GetRecordingRuleRequest, a, b);
  }
}

/**
 * @generated from message settings.v1.GetRecordingRuleResponse
 */
export class GetRecordingRuleResponse extends Message<GetRecordingRuleResponse> {
  /**
   * @generated from field: settings.v1.RecordingRule rule = 1;
   */
  rule?: RecordingRule;

  constructor(data?: PartialMessage<GetRecordingRuleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "settings.v1.GetRecordingRuleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule", kind: "message", T: RecordingRule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRecordingRuleResponse {
    return new GetRecordingRuleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRecordingRuleResponse {
    return new GetRecordingRuleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRecordingRuleResponse {
    return new GetRecordingRuleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetRecordingRuleResponse | PlainMessage<GetRecordingRuleResponse> | undefined, b: GetRecordingRuleResponse | PlainMessage<GetRecordingRuleResponse> | undefined): boolean {
    return proto3.util.equals(GetRecordingRuleResponse, a, b);
  }
}

/**
 * @generated from message settings.v1.ListRecordingRulesRequest
 */
export class ListRecordingRulesRequest extends Message<ListRecordingRulesRequest> {
  constructor(data?: PartialMessage<ListRecordingRulesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "settings.v1.ListRecordingRulesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListRecordingRulesRequest {
    return new ListRecordingRulesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListRecordingRulesRequest {
    return new ListRecordingRulesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListRecordingRulesRequest {
    return new ListRecordingRulesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListRecordingRulesRequest | PlainMessage<ListRecordingRulesRequest> | undefined, b: ListRecordingRulesRequest | PlainMessage<ListRecordingRulesRequest> | undefined): boolean {
    return proto3.util.equals(ListRecordingRulesRequest, a, b);
  }
}

/**
 * @generated from message settings.v1.ListRecordingRulesResponse
 */
export class ListRecordingRulesResponse extends Message<ListRecordingRulesResponse> {
  /**
   * @generated from field: repeated settings.v1.RecordingRule rules = 1;
   */
  rules: RecordingRule[] = [];

  constructor(data?: PartialMessage<ListRecordingRulesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "settings.v1.ListRecordingRulesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rules", kind: "message", T: RecordingRule, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListRecordingRulesResponse {
    return new ListRecordingRulesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListRecordingRulesResponse {
    return new ListRecordingRulesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListRecordingRulesResponse {
    return new ListRecordingRulesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListRecordingRulesResponse | PlainMessage<ListRecordingRulesResponse> | undefined, b: ListRecordingRulesResponse | PlainMessage<ListRecordingRulesResponse> | undefined): boolean {
    return proto3.util.equals(ListRecordingRulesResponse, a, b);
  }
}

/**
 * @generated from message settings.v1.UpsertRecordingRuleRequest
 */
export class UpsertRecordingRuleRequest extends Message<UpsertRecordingRuleRequest> {
  /**
   * The unique id of the recording rule. If an id is not provided, this will
   * create a new recording rule. If an id is provided, it will replace the
   * existing recording rule.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string metric_name = 2;
   */
  metricName = "";

  /**
   * @generated from field: repeated string matchers = 3;
   */
  matchers: string[] = [];

  /**
   * @generated from field: repeated string group_by = 4;
   */
  groupBy: string[] = [];

  /**
   * @generated from field: repeated types.v1.LabelPair external_labels = 5;
   */
  externalLabels: LabelPair[] = [];

  /**
   * The observed generation of this recording rule. If this value does not
   * match the generation stored in the database, this upsert will be rejected.
   *
   * @generated from field: int64 generation = 6;
   */
  generation = protoInt64.zero;

  constructor(data?: PartialMessage<UpsertRecordingRuleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "settings.v1.UpsertRecordingRuleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metric_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "matchers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "group_by", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "external_labels", kind: "message", T: LabelPair, repeated: true },
    { no: 6, name: "generation", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertRecordingRuleRequest {
    return new UpsertRecordingRuleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertRecordingRuleRequest {
    return new UpsertRecordingRuleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertRecordingRuleRequest {
    return new UpsertRecordingRuleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertRecordingRuleRequest | PlainMessage<UpsertRecordingRuleRequest> | undefined, b: UpsertRecordingRuleRequest | PlainMessage<UpsertRecordingRuleRequest> | undefined): boolean {
    return proto3.util.equals(UpsertRecordingRuleRequest, a, b);
  }
}

/**
 * @generated from message settings.v1.UpsertRecordingRuleResponse
 */
export class UpsertRecordingRuleResponse extends Message<UpsertRecordingRuleResponse> {
  /**
   * @generated from field: settings.v1.RecordingRule rule = 1;
   */
  rule?: RecordingRule;

  constructor(data?: PartialMessage<UpsertRecordingRuleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "settings.v1.UpsertRecordingRuleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule", kind: "message", T: RecordingRule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertRecordingRuleResponse {
    return new UpsertRecordingRuleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertRecordingRuleResponse {
    return new UpsertRecordingRuleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertRecordingRuleResponse {
    return new UpsertRecordingRuleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertRecordingRuleResponse | PlainMessage<UpsertRecordingRuleResponse> | undefined, b: UpsertRecordingRuleResponse | PlainMessage<UpsertRecordingRuleResponse> | undefined): boolean {
    return proto3.util.equals(UpsertRecordingRuleResponse, a, b);
  }
}

/**
 * @generated from message settings.v1.DeleteRecordingRuleRequest
 */
export class DeleteRecordingRuleRequest extends Message<DeleteRecordingRuleRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<DeleteRecordingRuleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "settings.v1.DeleteRecordingRuleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteRecordingRuleRequest {
    return new DeleteRecordingRuleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteRecordingRuleRequest {
    return new DeleteRecordingRuleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteRecordingRuleRequest {
    return new DeleteRecordingRuleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteRecordingRuleRequest | PlainMessage<DeleteRecordingRuleRequest> | undefined, b: DeleteRecordingRuleRequest | PlainMessage<DeleteRecordingRuleRequest> | undefined): boolean {
    return proto3.util.equals(DeleteRecordingRuleRequest, a, b);
  }
}

/**
 * @generated from message settings.v1.DeleteRecordingRuleResponse
 */
export class DeleteRecordingRuleResponse extends Message<DeleteRecordingRuleResponse> {
  constructor(data?: PartialMessage<DeleteRecordingRuleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "settings.v1.DeleteRecordingRuleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteRecordingRuleResponse {
    return new DeleteRecordingRuleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteRecordingRuleResponse {
    return new DeleteRecordingRuleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteRecordingRuleResponse {
    return new DeleteRecordingRuleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteRecordingRuleResponse | PlainMessage<DeleteRecordingRuleResponse> | undefined, b: DeleteRecordingRuleResponse | PlainMessage<DeleteRecordingRuleResponse> | undefined): boolean {
    return proto3.util.equals(DeleteRecordingRuleResponse, a, b);
  }
}

/**
 * @generated from message settings.v1.RecordingRule
 */
export class RecordingRule extends Message<RecordingRule> {
  /**
   * The unique id of the recording rule.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The name of the recording rule, this does not necessarily need to be
   * unique.
   *
   * @generated from field: string metric_name = 2;
   */
  metricName = "";

  /**
   * Used in the UI to display what type of profile type this recording rule is
   * generated from.
   *
   * This should be the standard format of:
   *
   *   <name>:<sample-type>:<sample-unit>:<period-type>:<period-unit>
   *
   * For example:
   *
   *   process_cpu:cpu:nanoseconds:cpu:nanoseconds
   *
   * @generated from field: string profile_type = 3;
   */
  profileType = "";

  /**
   * @generated from field: repeated string matchers = 4;
   */
  matchers: string[] = [];

  /**
   * @generated from field: repeated string group_by = 5;
   */
  groupBy: string[] = [];

  /**
   * @generated from field: repeated types.v1.LabelPair external_labels = 6;
   */
  externalLabels: LabelPair[] = [];

  /**
   * The observed generation of this recording rule. This value should be
   * provided when making updates to this record, to avoid conflicting
   * concurrent updates.
   *
   * @generated from field: int64 generation = 7;
   */
  generation = protoInt64.zero;

  constructor(data?: PartialMessage<RecordingRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "settings.v1.RecordingRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metric_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "profile_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "matchers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "group_by", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "external_labels", kind: "message", T: LabelPair, repeated: true },
    { no: 7, name: "generation", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordingRule {
    return new RecordingRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordingRule {
    return new RecordingRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordingRule {
    return new RecordingRule().fromJsonString(jsonString, options);
  }

  static equals(a: RecordingRule | PlainMessage<RecordingRule> | undefined, b: RecordingRule | PlainMessage<RecordingRule> | undefined): boolean {
    return proto3.util.equals(RecordingRule, a, b);
  }
}

/**
 * @generated from message settings.v1.RecordingRuleStore
 */
export class RecordingRuleStore extends Message<RecordingRuleStore> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string metric_name = 2;
   */
  metricName = "";

  /**
   * @generated from field: string prometheus_data_source = 3;
   */
  prometheusDataSource = "";

  /**
   * @generated from field: repeated string matchers = 4;
   */
  matchers: string[] = [];

  /**
   * @generated from field: repeated string group_by = 5;
   */
  groupBy: string[] = [];

  /**
   * @generated from field: repeated types.v1.LabelPair external_labels = 6;
   */
  externalLabels: LabelPair[] = [];

  /**
   * @generated from field: int64 generation = 7;
   */
  generation = protoInt64.zero;

  constructor(data?: PartialMessage<RecordingRuleStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "settings.v1.RecordingRuleStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metric_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "prometheus_data_source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "matchers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "group_by", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "external_labels", kind: "message", T: LabelPair, repeated: true },
    { no: 7, name: "generation", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordingRuleStore {
    return new RecordingRuleStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordingRuleStore {
    return new RecordingRuleStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordingRuleStore {
    return new RecordingRuleStore().fromJsonString(jsonString, options);
  }

  static equals(a: RecordingRuleStore | PlainMessage<RecordingRuleStore> | undefined, b: RecordingRuleStore | PlainMessage<RecordingRuleStore> | undefined): boolean {
    return proto3.util.equals(RecordingRuleStore, a, b);
  }
}

/**
 * @generated from message settings.v1.RecordingRulesStore
 */
export class RecordingRulesStore extends Message<RecordingRulesStore> {
  /**
   * @generated from field: repeated settings.v1.RecordingRuleStore rules = 1;
   */
  rules: RecordingRuleStore[] = [];

  /**
   * @generated from field: int64 generation = 2;
   */
  generation = protoInt64.zero;

  constructor(data?: PartialMessage<RecordingRulesStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "settings.v1.RecordingRulesStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rules", kind: "message", T: RecordingRuleStore, repeated: true },
    { no: 2, name: "generation", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordingRulesStore {
    return new RecordingRulesStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordingRulesStore {
    return new RecordingRulesStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordingRulesStore {
    return new RecordingRulesStore().fromJsonString(jsonString, options);
  }

  static equals(a: RecordingRulesStore | PlainMessage<RecordingRulesStore> | undefined, b: RecordingRulesStore | PlainMessage<RecordingRulesStore> | undefined): boolean {
    return proto3.util.equals(RecordingRulesStore, a, b);
  }
}

